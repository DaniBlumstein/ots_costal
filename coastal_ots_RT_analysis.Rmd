---
title: "ots28"
author: "Dani Blumstein"
date: "2025-01-08"
output: html_document
---
```{r}
library(openxlsx)
library(janitor)
library(dplyr)
library(tibble)
library(tidyr)
library(adegenet)
library(poppr)
library(tidyverse)
library(readxl)
library(adegenet)
library(dartR)
library(RColorBrewer)
library(igraph)
library(hierfstat)
library(reshape2)
library(ggplot2)
library(scales)
library(devtools)
library(splitstackshape)
library(cowplot)
library(gridGraphics)
library(ggrepel)
library(magrittr)
```

polarization
```{r}
run_timing<-as.data.frame(genos_all[, c(1, which(colnames(genos_all) %in% rt_markers$Assay))])

##check both in same order##
identical(run_timing$sample, meta$sample)

row.names(run_timing) <- run_timing$sample
#run_timing
#genind_run_timing

ots28_order <- as.data.frame(read.csv("~/projects/ots_coastal/Ots28markers.csv"))
ots28_order <- ots28_order[order(ots28_order$position, decreasing = F), ]

#remove the loci not in the dataset
remove <- c('Ots28_11033282','Ots37124-12279142','Ots37124-12281207','Ots28_11143508')
ots28_order<-ots28_order[!ots28_order$SFGLID %in%remove,]

##put markers in chromosomal order##
run_timing<-run_timing[ots28_order$SFGLID]
#run_timing<-cbind(meta$run,run_timing)




#now to start a bunch of maniputaion in R for an automated polarization

#make non diagnostic NA
run_timing_dig <- run_timing
run_timing_dig$Ots28_11062192 <- "NA"
run_timing_dig$Ots28_11186543 <- "NA"
run_timing_dig$Ots28_11202190 <- "NA"
run_timing_dig$Ots28_11202400 <- "NA"
run_timing_dig$Ots28_11202863 <- "NA"
run_timing_dig$Ots28_11205423 <- "NA"
run_timing_dig$Ots28_11205993 <- "NA"
run_timing_dig$Ots28_11206740 <- "NA"
run_timing_dig$Ots28_11207428 <- "NA"
run_timing_dig$Ots28_11210919 <- "NA"
run_timing_dig$'Ots37124-12267397' <- "NA"
run_timing_dig$'Ots37124-12270118' <- "NA"
run_timing_dig$'Ots37124-12272852' <- "NA"

#transpose the df and use the locus as the row names
test <- t(run_timing_dig)
test <- test %>%
  row_to_names(row_number = 1) 

#get the run code for each locus 
runtime_code <- as.data.frame(read_excel("runtime_code.xlsx",sheet = "diag"))
runtime_code_order <- runtime_code[order(match(runtime_code$locus, ots28_order$SFGLID)), ]

# new df to use in loop for recoding 
final_df <- run_timing_dig

# Create a vector of patterns and replacements
rep_str <- c("fall", "het", "spring", "NA","NA")

mylist <- list() #create an empty list

for (i in 1:ncol(final_df)) {
  col <- colnames(final_df)[i]
  # Loop through the nested list in df2
  for (j in 1:nrow(runtime_code_order)) {
    # Check if the col matches any value
    if (col == runtime_code_order[j,1]) {
       # Create a named vector for str_replace_all using correct syntax
      replacements <- c(
        runtime_code_order[j, 2], #fall geno # This should be the pattern to replace
        runtime_code_order[j, 3], #het geno
        runtime_code_order[j, 4], #spring geno
        runtime_code_order[j, 5], #mising geno "00"
        runtime_code_order[j, 6]  #NA for uninformred loci
      )
      # Apply str_replace_all (assuming final_df[,i] is a character vector)
      mylist[[i]] <- c(runtime_code_order[j,1],str_replace_all(final_df[,i], setNames(rep_str, replacements)))
    }
  }
}

df <- as.data.frame(do.call("rbind",mylist)) #combine all vectors into a matrix

#add the sample names back. I don't like how i did this as i worry it could be innaccurate I just have no clue how to do it otherwise at the moment
names <- c("locus", rownames(final_df))
colnames(df) <- names

#order the loci to chr order
df_order <- df[order(match(rownames(df), ots28_order$SFGLID)), ]

# Reshape the dataframe from wide to long format
df_long <- df_order %>%
  pivot_longer(cols = -locus , names_to = "sample", values_to = "geno")

#note neither of these are in chr order and for reasons unknown I can't get ggplot to plot in DF order
#polarization 
ggplot(df_long,aes(locus,sample,fill= geno)) + 
  geom_tile()+
  theme(axis.text.x = element_text(angle = 45))

#add allllll the metadata in 
df_long_merge<- merge(df_long,meta,by = "sample")

#funtion to calculate proportion of genotypic run
prop <- function(count, group) {
  count / tapply(count, group, sum)[group]
}

ggplot(df_long_merge, aes(x = run, y = prop(after_stat(count), after_stat(x)),
  fill = geno, after_stat(x)))+ 
   geom_bar(position = position_fill())+
  facet_grid(Population~locus)+
  ggtheme

# add metadata to the raw data from waaaaay back when. did this at the end as its just ended up being cleaner
run_timing<-cbind(meta,run_timing)

##write run timing markers to csv for polarization in excel
write.xlsx(run_timing, quote = FALSE, rownames = FALSE, file = "runtiming_genotypes.xlsx")

```

individual level PCA (missing data filled in with mean genotype)
```{r}
nm_df<-as.data.frame(rownames(genind_run_timing$tab))
colnames(nm_df)<-"sample"
identical(nm_df$sample, meta$sample)
nm_df<-cbind(nm_df, meta$Population)

##add Population classification as population identifier to genind object of run timing markers
genind_run_timing$pop<-as.factor(nm_df$`meta$Population`)
run_timing_loci<-genind2loci(genind_run_timing) 


# Replace missing data with the mean allele frequencies
x = tab(genind_run_timing, NA.method = "mean")

# Perform PCA
pca1 = dudi.pca(x, scannf = FALSE, scale = FALSE, nf = 3)

# Analyse how much percent of genetic variance is explained by each axis
percent = pca1$eig/sum(pca1$eig)*100
barplot(percent, ylab = "Genetic variance explained by eigenvectors (%)", ylim = c(0,12),
        names.arg = round(percent, 1))

# Create a data.frame containing individual coordinates
ind_coords = as.data.frame(pca1$li)

# Rename columns of dataframe
colnames(ind_coords) = c("Axis1","Axis2","Axis3")

# Add a column containing individuals
ind_coords$Ind = indNames(genind_run_timing)

# Add a column with the site IDs
ind_coords$Site = genind_run_timing$pop

# Calculate centroid (average) position for each population
centroid = aggregate(cbind(Axis1, Axis2, Axis3) ~ Site, data = ind_coords, FUN = mean)

# Add centroid coordinates to ind_coords dataframe
ind_coords = left_join(ind_coords, centroid, by = "Site", suffix = c("",".cen"))

# Define colour palette
#cols = brewer.pal(nPop(neutral_genind), "Set1")

# Custom x and y labels
xlab = paste("Axis 1 (", format(round(percent[1], 1), nsmall=1)," %)", sep="")
ylab = paste("Axis 2 (", format(round(percent[2], 1), nsmall=1)," %)", sep="")

# Custom theme for ggplot2
ggtheme = theme(axis.text.y = element_text(colour="black", size=12),
                axis.text.x = element_text(colour="black", size=12),
                axis.title = element_text(colour="black", size=12),
                panel.border = element_rect(colour="black", fill=NA, size=1),
                panel.background = element_blank(),
                plot.title = element_text(hjust=0.5, size=15) 
)

# Scatter plot axis 1 vs. 2
ggplot(data = ind_coords, aes(x = Axis1, y = Axis2))+
  geom_hline(yintercept = 0)+
  geom_vline(xintercept = 0)+
  # spider segments
  geom_segment(aes(xend = Axis1.cen, yend = Axis2.cen, colour = Site), show.legend = FALSE)+
  # points
  geom_point(aes(fill = Site), shape = 21, size = 3, show.legend = FALSE)+
  # centroids
  geom_label(data = centroid, aes(label = Site, fill = Site), size = 4, show.legend = FALSE)+
  # colouring
  #scale_fill_manual(values = cols)+
  #scale_colour_manual(values = cols)+
  # custom labels
  labs(x = xlab, y = ylab)+
  ggtitle("runtiming PCA")+
  # custom theme
  ggtheme
```

population level PCA
```{r}
# Conversion to genpop
run_timing_genpop <- genind2genpop(genind_run_timing)

# Replace missing data with the mean allele frequencies
x = tab(run_timing_genpop)

# Perform PCA
pca2 = dudi.pca(x, scannf = FALSE, scale = FALSE, nf = 3)

# Analyse how much percent of genetic variance is explained by each axis
percent = pca2$eig/sum(pca2$eig)*100
barplot(percent, ylab = "Genetic variance explained by eigenvectors (%)", ylim = c(0,12),
        names.arg = round(percent, 1))

pop_pcs <- pca2$li

#create column of sample IDs from rownames##
pop_pcs %<>%
  rownames_to_column(var = "pop") 

ggplot(pop_pcs)+
  geom_point(aes(Axis1, Axis2, color = pop), alpha = 0.7, size = 5.0)+
  geom_text_repel(aes(x=Axis1, y=Axis2, label = pop), nudge_x = 0.015, nudge_y = 0.015, size = 4, alpha = 0.8, force = 6, max.overlaps = 15, min.segment.length = 0.8, segment.colour = "darkgrey", segment.size = 1) +
  xlab("PC1 72.3%")+
  ylab("PC2 27.3%")
```

CCA and RDA
